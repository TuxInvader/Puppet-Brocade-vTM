#!/bin/sh
# Copyright (C) 2019, Pulse Secure, LLC. All rights reserved.

# WARNING - Do not edit this file, it is managed by the traffic manager.
#           Any changes will be lost on upgrade.
#           To use an amended version of this file re-upload a copy of it
#           as a custom user plugin.

if [ -z "$ZEUSHOME" ]
then
   # Have a good guess, we live in $ZEUSHOME/zxtm/conf/servicediscovery
   OLD_PWD=`pwd`
   cd `dirname $0`/../../..
   if [ -d 'zxtm/bin' ]
   then
      ZEUSHOME=`pwd`
      export ZEUSHOME
   fi
   cd $OLD_PWD
fi

if [ ! -z "$ZEUSHOME" ]
then
   PROG=$ZEUSHOME/perl/miniperl
else
   echo "Failed to determine ZEUSHOME" >2
   exit 1
fi

exec $PROG -x $0 ${1+"$@"}
#!perl -w
#line 33

BEGIN { unshift @INC, "$ENV{ZEUSHOME}/zxtm/lib/perl",
     "$ENV{ZEUSHOME}/zxtmadmin/lib/perl", "$ENV{ZEUSHOME}/perl" }

use strict;
use Getopt::Long qw( GetOptions );
use JSON;
use Socket;

# Strings used when extracting tokens from the healthcheck API.
my $ANCHOR = "(?:^|[^0-9A-Za-z_-])";
   # Beginning of Word/Beginning of line, in a non-capture group,
   # (and word includes numbers, underbar & hyphen, but not html's </>)
my $USER_COUNT_TAG = "USER-COUNT";
my $PLATFORM_LIMIT_TAG = "PLATFORM-LIMIT";
my $LICENSE_LIMIT_TAG = "MAXIMUM-LICENSED-USER-COUNT";

# Other Strings used in the plugin.
my $INVALID_ARGS = "Invalid arguments for PCS/PPS Service Discovery Script";

my $output = { "version" => 1,
               "nodes" => [],
               "code" => 200 };

sub output_json()
{
   print encode_json( $output );
}

sub error($$)
{
   # Over-write any warnings reported and replace the error field
   # with final error and exit.
   my( $code, $msg ) = @_;
   $output->{'error'} = $msg;
   $output->{'code'} = $code;
   delete( $output->{'nodes'} );
   output_json();
   exit( 1 );
}

sub info($)
{
   my( $msg ) = @_;
   $output->{'info'} .= $msg . ". ";
}

my $opts = {};
if( !GetOptions( $opts,
                 'nodes|n:s',
                 'info|i',
                 'verbose|v',
               )
   ) {
   error( 400, $INVALID_ARGS );
}

# Get a list of nodes, might be comma or space separated
my @nodes = ();
my $nodes_arg = $opts->{'nodes'};
if( $nodes_arg ) {
   # Split on comma (and any following space) or any space,
   # ?: - don't capture.
   @nodes = split( /(?:,\s*)|(?:\s+)/, $nodes_arg );
}

my $verbose = $opts->{'verbose'};
my $info_opt = $opts->{'info'};

sub verbose_to_stderr
{
   my( @parts ) = @_;

   if( $verbose ) {
      print( STDERR join( '', @parts ), "\n" );
   }
}

if( !scalar( @nodes) ) {
   error( 400, $INVALID_ARGS . ": '--nodes' required." );
}

# Parse the nodes arguments:
# The format of each and every node is either
#    <hostname>:<port>/<maxusers>
# or
#    <hostname>:<port>
#
# Split out each component then iterate through all the nodes provided and
# return the weight encoded in JSON to the Service Discovery lb code.

my $node_args_with_maxusers = 0;
my @parsed_nodes = ();

foreach my $node ( @nodes ) {
   my ( $host_and_port, $maxusers ) = split( '/', $node, 2 );

   $host_and_port //= ''; # Handle undef caused by empty $nodes string.

   if( defined( $maxusers ) ) {
      if( $maxusers =~ /^\d+$/ ) {
         $node_args_with_maxusers++;
      } else {
         error( 400,
            $INVALID_ARGS .
               ": Non numeric found for maxusers for $host_and_port.\n"
         );
      }
   }

   # RFC 3986, section 3.2.2, IPv6 addresses must use [1::0]:port format
   my ( $host, $port );
   if( $host_and_port =~ m/^(.*):(\d+)$/ ) {
      $host = $1;
      $port = $2;
   } else {
      error( 400, "Cannot split $host_and_port into host:port" );
   }
   push( @parsed_nodes,
      {
         host => $host,
         port => $port,
         maxusers => $maxusers
      }
   );
}

# Check that maxusers is supplied for all nodes or none.
if( $node_args_with_maxusers != 0 &&
    $node_args_with_maxusers != scalar( @nodes )
) {
   error( 400,
      $INVALID_ARGS .
         ": Maxusers must be specified for all nodes or no nodes" .
         " in a Pool's Service Discovery Plugin arguments."
   );
}

# Iterate through all the nodes provided and
# return the weight encoded in JSON to the Service Discovery lb code.

my @nodes_without_limits = (); # Nodes which have USER_COUNT but no limits.
my %hosts;

foreach my $node ( @parsed_nodes ) {
   my ( $host ) = $node->{host};
   my ( $port ) = $node->{port};
   my ( $maxusers ) = $node->{maxusers};

   # Run httpclient and look for a regex matching "USER-COUNT=[0-9]*;"
   my $healthcheck_url = "/dana-na/healthcheck/healthcheck.cgi?status=all";
   my $url = "https://" . $host . $healthcheck_url;

   verbose_to_stderr( "host = $host" );
   verbose_to_stderr( "port = $port" );
   verbose_to_stderr( "url = $url" );

   open( HEALTH, "-|", "$ENV{ZEUSHOME}/admin/bin/httpclient", "-t", "5", "$url" ) ||
     error( 400, "Cannot run $ENV{ZEUSHOME}/admin/bin/httpclient: $!" );
   my $first_line = <HEALTH>;

   # Check http status. 200 is Good, 100s or 200s report info.
   # 300s 400 or 500 report as and error and Ignore node.
   if( !$first_line ) {
      # Didn't get a status code at all. Empty response or httpclient error?
      my $error;
      if( close HEALTH ) {
         # Empty response.
         $error = "HealthCheck API for $url didn't return anything.";
      } else {
         $error = "httpclient returned: $! $?";
      }
      $output->{'error'} .=
         ( $output->{'error'} ? ' ' : '' ) # Message separator.
         . $error;
      next;
   }
   if( $first_line !~ m/ 200 / ) {
      if( $first_line =~ m/([12][0-9][0-9])/ ) {
         info( "HealthCheck API for $url returned $1." );
      } elsif( $first_line =~ m/([3-5][0-9][0-9])/ ) {
         my $status_code = $1;
         my $error;
         if( close HEALTH ) {
            $error = "HealthCheck API for $url returned $status_code " .
               "(httpclient returned: $! $?)";
         } else {
            $error = "HealthCheck API for $url returned $status_code.";
         }
         $output->{'error'} .=
            ( $output->{'error'} ? ' ' : '' ) # Messages separator.
            . $error;
         next;
      } else {
         # Maybe didn't get a status code at all.
         $output->{'error'} .=
            ( $output->{'error'} ? ' ' : '' ) # Messages separator.
            . "HealthCheck API for $url did not return a status line.";
         close HEALTH;
         next;
      }
   }
   verbose_to_stderr( $first_line );
   my( $user_count, $platform_limit, $license_limit );

   while( my $line = <HEALTH> ) {
      chomp ($line);
      verbose_to_stderr( "http response:   $line" );
      # Extract items of interest: user_count, platform_limit & license_limit
      if(
         $line =~ /$ANCHOR\Q$USER_COUNT_TAG=\E\s*(\d+)\s*;/
      ) {
         $user_count = $1;
         verbose_to_stderr( "HealthCheck reports $user_count users." );
      } elsif( $node_args_with_maxusers == 0 ) {
         # Extact limits only if no maxuser counts arguments were provided.
         if(
            $line =~ /$ANCHOR\Q$PLATFORM_LIMIT_TAG=\E\s*(\d+)\s*;/
         ) {
            $platform_limit = $1;
            verbose_to_stderr(
               "HealthCheck reports $platform_limit limit for platform."
            );
         } elsif(
            $line =~ /$ANCHOR\Q$LICENSE_LIMIT_TAG=\E\s*(\d+)\s*;/
         ) {
            $license_limit = $1;
            verbose_to_stderr(
               "HealthCheck reports $license_limit limit for license."
            );
         }
      }
   }
   verbose_to_stderr( "\n" );
   close HEALTH || error( 400, "httpclient returned: $! $?" );

   # Having parsed API Output, take the lower limit of platform/license.
   if( $node_args_with_maxusers == 0 ) {
      if( defined( $platform_limit ) && defined( $license_limit ) ) {
         $maxusers = ( $platform_limit < $license_limit ) ?
               $platform_limit : $license_limit;
      } else {
         $maxusers = $platform_limit // $license_limit;
      }
   }

   my $weight;

   if( ! defined( $maxusers ) ) {
      # For Error logging purposes, note nodes with undefined limits.
      if( defined( $user_count ) ) {
         # Valid API just no LIMIT fields, (from and old style PCS/PPS)?
         push( @nodes_without_limits, { 'host' => $host, 'port' => $port } );
      }
      verbose_to_stderr( "maxusers undefined for $host:$port." );
      $weight = 1;
   } else {
      verbose_to_stderr( "maxusers = $maxusers for $host:$port." );
      if( ! defined( $user_count ) ) {
         # Couldn't parse the Health Check API output.
         info( "Cannot parse session count for $host:$port" );
         verbose_to_stderr( "Cannot parse session count for $host:$port" );
         $weight = 1;
      } else {
         $weight = $maxusers - $user_count;
         verbose_to_stderr( "weight = $maxusers - $user_count = $weight" );
      }
   }
   $hosts{ $host }{ $port } = $weight;
}

if( ! scalar( keys( %hosts ) ) ) {
   # No hosts returned is serious.
   error( 400,
      "Could not obtain necessary information from any node's Healthcheck API."
   );
}

my $max_weight = 0;
foreach my $host ( keys %hosts ) {
   foreach my $port ( keys %{ $hosts{$host} } ) {
      my $weight = $hosts{ $host }{ $port };
      if( $weight > $max_weight ) {
         $max_weight = $weight;
      }
   }
}
if( $max_weight > 100 ) {
   verbose_to_stderr( "scaling down weights to <= 100" );
   my $scale_factor = $max_weight / 100;
   foreach my $host ( keys %hosts ) {
      foreach my $port (keys %{ $hosts{$host} }) {
         my $weight = $hosts{ $host }{ $port };
         $weight /= $scale_factor;
         $hosts{ $host }{ $port } = $weight;  # Scale down each weight
      }
   }
}

foreach my $host ( keys %hosts ) {
   foreach my $port ( keys %{ $hosts{$host} } ) {
      my $weight = $hosts{ $host }{ $port };
      $weight = int( $weight );
      $port = int( $port );
      # Weights must be in the range 1-100
      $weight = 1 if( $weight < 1 );
      $weight = 100 if( $weight > 100 );
      if( $host =~ m/\[(.*)\]/ ) {
         $host = $1;
      }

      open( DNSLOOKUP, "$ENV{ZEUSHOME}/admin/bin/zdns -l $host |" ) ||
        error( 400, "Cannot run $ENV{ZEUSHOME}/admin/bin/zdns: $!" );

      my @ip_addrs;
      while( <DNSLOOKUP> ) {
        chomp;
        push( @{$output->{'nodes'}},
          { 'ip' => $_,
            'port' => int( $port ),
            'weight' => int( $weight )
          } );
      }
      info( "Host $host:$port, weight = $weight" ) if( $info_opt );
      close DNSLOOKUP || error( 400, "zdns returned: $! $?" );
   }
}
# Report on any nodes without limits.
if( scalar( @nodes_without_limits ) ) {
   $output->{'error'} = "Failed to get limits from the following nodes:" .
      join( ', ', map( "$_->{host}:$_->{port}", @nodes_without_limits ) ) .
      "; These limits are only available from PCS/PPS version 9.1R3 onwards.";
}

output_json();
print "\n";

exit 0;
